/*
 *
 * DQMEventCollector.cc source template automatically generated by a class generator
 * Creation date : mer. sept. 9 2015
 *
 * This file is part of DQM4HEP libraries.
 * 
 * DQM4HEP is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * DQM4HEP is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with DQM4HEP.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */

// -- dqm4hep headers
#include "dqm4hep/EventCollector.h"
#include "DQMOnlineConfig.h"
#include "dqm4hep/Logging.h"

namespace dqm4hep {

  namespace online {
    
    EventCollector::EventCollector() : 
      Application()
    {      
    }

    //-------------------------------------------------------------------------------------------------

    void EventCollector::parseCmdLine(int argc, char **argv) {
      std::string cmdLineFooter = "Please report bug to <dqm4hep@gmail.com>";
      m_cmdLine = std::make_shared<TCLAP::CmdLine>(cmdLineFooter, ' ', DQMOnline_VERSION_STR);
      
      TCLAP::ValueArg<std::string> collectorNameArg(
          "c"
          , "collector-name"
          , "The event collector name"
          , true
          , ""
          , "string");
      m_cmdLine->add(collectorNameArg);
      
      core::StringVector verbosities(core::Logger::logLevels());
      TCLAP::ValuesConstraint<std::string> verbosityConstraint(verbosities);
      TCLAP::ValueArg<std::string> verbosityArg(
          "v"
          , "verbosity"
          , "The logging verbosity"
          , false
          , "info"
          , &verbosityConstraint);
      m_cmdLine->add(verbosityArg);
      
      // parse command line
      m_cmdLine->parse(argc, argv);

      // set log level
      std::string verbosity(verbosityArg.getValue());
      core::Logger::setLogLevel(core::Logger::logLevelFromString(verbosity));;

      std::string collectorName(collectorNameArg.getValue());
      this->setType("evtcol");
      this->setName(collectorName);
    }
    
    //-------------------------------------------------------------------------------------------------
    
    void EventCollector::onInit() {
      // create network services
      this->createRequestHandler("/dqm4hep/app/evtcol/" + this->name() + "/register");
      this->createDirectCommand("/dqm4hep/app/evtcol/" + this->name() + "/unregister");
      this->createDirectCommand("/dqm4hep/app/evtcol/" + this->name() + "/collect");
      
      // create statistics entries
      this->createStatsEntry("NSources", "", "The current number of registered sources");
      this->createStatsEntry("NEvents_60sec", "1/min", "The number of collected events within the last minute");
      this->createStatsEntry("NEvents_10sec", "1/10 sec", "The number of collected events within the last 10 secondes");
      this->createStatsEntry("NBytes_60sec", "bytes", "The total number of collected bytes within the last minute");
      this->createStatsEntry("NBytes_10sec", "bytes", "The total number of collected bytes within the last 10 secondes");
      this->createStatsEntry("NMeanBytes_60sec", "bytes/min", "The mean number of collected bytes within the last minute");
      this->createStatsEntry("NMeanBytes_10sec", "bytes/10 sec", "The mean number of collected bytes within the last 10 secondes");
      
      // app stats timers
      this->createTimer("CollectorStats10Secs", 10, true, this, &EventCollector::sendStatsTimer10);
      this->createTimer("CollectorStats60Secs", 60, true, this, &EventCollector::sendStatsTimer60);
      m_lastStatCall10 = core::now();
      m_lastStatCall60 = core::now();
    }
    
    //-------------------------------------------------------------------------------------------------
    
    void EventCollector::onEvent(AppEvent *pAppEvent) {
      if(pAppEvent->type() == AppEvent::REQUEST_HANDLING) {
        RequestEvent *request = (RequestEvent *) pAppEvent;
        if(request->requestName() == "/dqm4hep/app/evtcol/" + this->name() + "/register") {
          this->handleRegistration(request);
        }
      }
      else if(pAppEvent->type() == AppEvent::CLIENT_EXIT) {
        ClientExitEvent *pClientExitEvent = (ClientExitEvent *) pAppEvent;
        this->handleClientExit(pClientExitEvent);
      }
      if(pAppEvent->type() == AppEvent::COMMAND_HANDLING) {
        CommandEvent *command = (CommandEvent *) pAppEvent;
        if(command->commandName() == "/dqm4hep/app/evtcol/" + this->name() + "/collect") {
          this->handleCollectEvent(command);
        }
        else if(command->commandName() == "/dqm4hep/app/evtcol/" + this->name() + "/unregister") {
          this->handleClientUnregistration(command);
        }
      }
    }
    
    //-------------------------------------------------------------------------------------------------
    
    void EventCollector::onStart() {
    }
    
    //-------------------------------------------------------------------------------------------------
    
    void EventCollector::onStop() {
    }
    
    //-------------------------------------------------------------------------------------------------
    
    void EventCollector::handleRegistration(RequestEvent *request) {
      core::json registrationDetails({});
      if(0 != request->request().size()) {
        registrationDetails = core::json::parse(request->request().begin(), request->request().end());   
      }
      auto clientSourceName = registrationDetails.value<std::string>("source", "");
      auto clientId = this->serverClientId();  
      auto findIter = m_sourceInfoMap.find(clientSourceName);
      core::json clientResponseValue({});
      
      // source already registered
      if(m_sourceInfoMap.end() != findIter) {
        if(clientId == findIter->second.m_clientId) {
          clientResponseValue["message"] = "Event source already registered !";
          clientResponseValue["registered"] = true;
        }
        else {
          std::stringstream ss; ss << "Event source already registered with a different client ID (" << findIter->second.m_clientId << ") !";
          clientResponseValue["message"] = ss.str();
          clientResponseValue["registered"] = false;
        }
      }
      // source not registered yet
      else {
        std::string sourceName = registrationDetails.value<std::string>("source", "");
        SourceInfo sourceInfo;
        findIter = m_sourceInfoMap.insert(SourceInfoMap::value_type(sourceName, std::move(sourceInfo))).first;
        
        findIter->second.m_clientId = clientId;
        findIter->second.m_name = registrationDetails.value<std::string>("source", "");
        findIter->second.m_streamerName = registrationDetails.value<std::string>("streamer", "");
        
        auto collectors = registrationDetails["collectors"];
        auto hostInfo = registrationDetails["host"];
        
        for(auto collector : collectors) {
          findIter->second.m_collectors.push_back(collector.get<std::string>());
        }
          
        for(auto hostInfoIter : hostInfo.items()) {
          findIter->second.m_hostInfo[hostInfoIter.key()] = hostInfo[hostInfoIter.key()].get<std::string>();
        }
        
        auto model = findIter->second.m_buffer.createModel<std::string>();
        findIter->second.m_buffer.setModel(model);
        
        dqm_info( "New event source '{0}' registered with client id {1}", findIter->second.m_name, findIter->second.m_clientId );
        
        clientResponseValue["registered"] = true;
        sendStat("NSources", m_sourceInfoMap.size());
      }
      
      auto model = request->response().createModel<std::string>();
      request->response().setModel(model);
      model->copy(clientResponseValue.dump());
    }
    
    //-------------------------------------------------------------------------------------------------
    
    void EventCollector::handleClientExit(ClientExitEvent *event) {
      const int clientId(event->clientId());
      auto findIter = std::find_if(m_sourceInfoMap.begin(), m_sourceInfoMap.end(), [&clientId](const SourceInfoMap::value_type &iter){
        return (iter.second.m_clientId == clientId);
      });
      
      if(findIter != m_sourceInfoMap.end()) {
        dqm_info( "Removing event source '{0}' from source list !", findIter->second.m_name );
        m_sourceInfoMap.erase(findIter);
        sendStat("NSources", m_sourceInfoMap.size());
      }
    }
    
    //-------------------------------------------------------------------------------------------------
    
    void EventCollector::handleCollectEvent(CommandEvent *command) {
      const int clientId(this->serverClientId());
      
      auto findIter = std::find_if(m_sourceInfoMap.begin(), m_sourceInfoMap.end(), [&clientId](const SourceInfoMap::value_type &iter){
        return (iter.second.m_clientId == clientId);
      });
      
      if(findIter != m_sourceInfoMap.end()) {
        auto &bufferCollect = command->buffer();            
        std::string copiedBuffer(bufferCollect.begin(), bufferCollect.size());
        auto newModel = findIter->second.m_buffer.createModel<std::string>();
        findIter->second.m_buffer.setModel(newModel);
        newModel->move(std::move(copiedBuffer));
      }
    }
    
    //-------------------------------------------------------------------------------------------------
    
    void EventCollector::handleClientUnregistration(CommandEvent *event) {
      const int clientId(this->serverClientId());
      auto findIter = std::find_if(m_sourceInfoMap.begin(), m_sourceInfoMap.end(), [&clientId](const SourceInfoMap::value_type &iter){
        return (iter.second.m_clientId == clientId);
      });
      
      if(findIter != m_sourceInfoMap.end()) {
        dqm_info( "Removing event source '{0}' from source list !", findIter->second.m_name );
        m_sourceInfoMap.erase(findIter);
      }
    }
    
    //-------------------------------------------------------------------------------------------------
    
    void EventCollector::sendStatsTimer10() {
      auto timeDifference = (core::now()-m_lastStatCall10).count();
      // send stats
      sendStat("NEvents_10sec", m_nCollectedEvents10);
      sendStat("NBytes_10sec", m_nCollectedBytes10);
      sendStat("NMeanBytes_10sec", m_nCollectedBytes10 / (timeDifference*1.));
      // reset counters
      m_nCollectedEvents10 = 0;
      m_nCollectedBytes10 = 0;
      m_lastStatCall10 = core::now();
    }
    
    //-------------------------------------------------------------------------------------------------
    
    void EventCollector::sendStatsTimer60() {
      auto timeDifference = (core::now()-m_lastStatCall60).count();
      // send stats
      sendStat("NEvents_60sec", m_nCollectedEvents60);
      sendStat("NBytes_60sec", m_nCollectedBytes60);
      sendStat("NMeanBytes_60sec", m_nCollectedBytes60 / (timeDifference*1.));
      // reset counters
      m_nCollectedEvents60 = 0;
      m_nCollectedBytes60 = 0;
      m_lastStatCall60 = core::now();
    }
    
    //-------------------------------------------------------------------------------------------------
    
    void EventCollector::printSourceMap() {
      for(auto &source : m_sourceInfoMap) {
        dqm_debug( "== Source '{0}' ==", source.first );
        dqm_debug( "     Client id: '{0}' ==", source.second.m_clientId );
        dqm_debug( "     Streamer:  '{0}' ==", source.second.m_streamerName );
      }
    }
    
    //-------------------------------------------------------------------------------------------------
    //-------------------------------------------------------------------------------------------------
    
    EventCollector::SourceInfo::SourceInfo(EventCollector::SourceInfo&& info) :
      m_clientId(std::move(m_clientId)),
      m_name(std::move(m_name)),
      m_streamerName(std::move(m_streamerName)),
      m_collectors(std::move(m_collectors)),
      m_hostInfo(std::move(m_hostInfo)),
      m_buffer(std::move(m_buffer))
    {
    }

  }

}
