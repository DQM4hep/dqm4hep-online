/// \file Application.cc
/*
 *
 * Application.cc source template automatically generated by a class generator
 * Creation date : ven. sept. 5 2014
 *
 * This file is part of DQM4HEP libraries.
 * 
 * DQM4HEP is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * DQM4HEP is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with DQM4HEP.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */

// -- dqm4hep headers
#include "dqm4hep/Application.h"
#include "dqm4hep/Logging.h"

namespace dqm4hep {

  namespace online {
    
    const std::string &Application::type() const
    {
      return m_type;
    }
    
    //-------------------------------------------------------------------------------------------------
    
    void Application::setType(const std::string &type)
    {
      if(this->initialized())
      {
        dqm_error( "Application::setType(): Couldn't set app type, app is already initialized !" );
        throw core::StatusCodeException(core::STATUS_CODE_NOT_ALLOWED);
      }
      
      m_type = type;
    }
    
    //-------------------------------------------------------------------------------------------------

    const std::string &Application::name() const
    {
      return m_name;
    }
    
    //-------------------------------------------------------------------------------------------------

    void Application::setName(const std::string &name)
    {
      if(this->initialized())
      {
        dqm_error( "Application::setName(): Couldn't set app name, app is already initialized !" );
        throw core::StatusCodeException(core::STATUS_CODE_NOT_ALLOWED);
      }
      
      m_name = name;
    }
    
    //-------------------------------------------------------------------------------------------------
    
    const std::string &Application::state() const
    {
      return m_state;
    }
    
    //-------------------------------------------------------------------------------------------------
    
    void Application::setState(const std::string &state)
    {
      m_state = state;
      
      if(m_pAppStateService && m_server && m_server->isRunning())
        m_pAppStateService->send(m_state);
    }
    
    //-------------------------------------------------------------------------------------------------

    void Application::createStatsEntry(const std::string &name, const std::string &description)
    {
      if(this->initialized())
      {
        dqm_error( "Application::createStatsEntry(): Couldn't create stat entry, app is already initialized !" );
        throw core::StatusCodeException(core::STATUS_CODE_NOT_ALLOWED);
      }
      
      if(m_statistics["stats"].isMember(name))
        throw core::StatusCodeException(core::STATUS_CODE_ALREADY_PRESENT);
      
      // fill entry info
      Json::Value stat;
      stat["description"] = description;
      stat["value"] = 0.;
      
      // add entry
      m_statistics["stats"][name] = stat;
    }
  
    //-------------------------------------------------------------------------------------------------

    void Application::updateStats(const std::string &name, double stats)
    {
      if(!this->statsEnabled())
        return;
        
      if(!m_statistics["stats"].isMember(name))
        throw core::StatusCodeException(core::STATUS_CODE_NOT_FOUND);
      
      m_statistics["stats"][name]["value"] = stats;
      Json::Value statValue(m_statistics["stats"][name]);
      
      Json::StreamWriterBuilder builder;
      std::unique_ptr<Json::StreamWriter> writer(builder.newStreamWriter());
      std::ostringstream jsonString;
      writer->write(statValue, &jsonString);
      
      m_pAppStatsService->send(jsonString.str());
    }

    //-------------------------------------------------------------------------------------------------    

    void Application::enableStats(bool enable)
    {
      if(this->initialized())
      {
        dqm_error( "Application::enableStats(): Couldn't enable/disable stats, app is already initialized !" );
        throw core::StatusCodeException(core::STATUS_CODE_NOT_ALLOWED);
      }
      
      m_statsEnabled = enable;
    }
    
    //-------------------------------------------------------------------------------------------------

    bool Application::statsEnabled() const
    {
      return m_statsEnabled;
    }
    
    //-------------------------------------------------------------------------------------------------

    void Application::init(int argc, char **argv)
    {
      if(this->initialized())
      {
        dqm_error( "Application::init(): app already initialized !" );
        throw core::StatusCodeException(core::STATUS_CODE_ALREADY_INITIALIZED);        
      }
      
      try
      {
        this->parseCmdLine(argc, argv);        
      }
      catch(...)
      {
        dqm_error( "Application::init(): failed to parse cmd line !" );
        throw core::StatusCodeException(core::STATUS_CODE_FAILURE);
      }
      
      std::string baseName = "/dqm4hep/app/";
      std::string serverName = baseName + this->type() + "/" + this->name();
      m_server = std::make_shared<net::Server>(serverName);
      m_pAppStateService = m_server->createService(serverName + "/state");
      m_pAppStatsService = m_server->createService(serverName + "/stats");
      
      m_statistics["appType"] = this->type();
      m_statistics["appName"] = this->name();
      m_statistics["stats"] = Json::Value(Json::objectValue);
      
      try
      {
        this->onInit();        
      }
      catch(...)
      {
        dqm_error( "Application::init(): failed to initialize the app !" );
        throw core::StatusCodeException(core::STATUS_CODE_FAILURE);
      }
      
      m_initialized = true;
    }
    
    //-------------------------------------------------------------------------------------------------
    
    int Application::exec()
    {
      m_running = true;
      
      m_server->start();
      this->setState("Running");
      
      try
      {
        this->onStart();
      }
      catch(...)
      {
        dqm_error( "Application::init(): failed to start the app !" );
        throw core::StatusCodeException(core::STATUS_CODE_FAILURE);
      }
      
      int returnCode(0);
      
      try
      {
        returnCode = m_eventLoop.exec();
        this->onStop();
      }
      catch(...)
      {
        dqm_error( "Application::init(): failed to start the app !" );
        throw core::StatusCodeException(core::STATUS_CODE_FAILURE);
      }
      
      std::stringstream state; state << "Exiting (" << returnCode << ")"; 
      this->setState(state.str());
      m_running = false;
      
      return returnCode;
    }

    //-------------------------------------------------------------------------------------------------

    void Application::exit(int returnCode)
    {
      m_eventLoop.exit(returnCode);
    }
    
    //-------------------------------------------------------------------------------------------------

    bool Application::initialized() const
    {
      return m_initialized;
    }

    //-------------------------------------------------------------------------------------------------    

    bool Application::running() const
    {
      return m_running;
    }

  }

}

