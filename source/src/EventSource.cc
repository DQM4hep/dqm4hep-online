/// \file EventSource.cc
/*
 *
 * EventSource.cc source template automatically generated by a class generator
 * Creation date : mar. sept. 8 2015
 *
 * This file is part of DQM4HEP libraries.
 * 
 * DQM4HEP is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * DQM4HEP is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with DQM4HEP.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */

// -- dqm4hep headers
#include "dqm4hep/EventSource.h"
#include "dqm4hep/Logging.h"
#include "dqm4hep/PluginManager.h"

namespace dqm4hep {

  namespace core {

    EventSource::EventSource(const std::string &sourceName) :
        m_sourceName(sourceName)
    {
      /* nop */
    }
    
    //-------------------------------------------------------------------------------------------------
    
    EventSource::~EventSource()
    {
      for(auto colIter : m_collectorInfos)
        this->unregisterMe(colIter.first);
    }

    //-------------------------------------------------------------------------------------------------

    const std::string &EventSource::sourceName() const
    {
      return m_sourceName;
    }
    
    //-------------------------------------------------------------------------------------------------

    void EventSource::setStreamerName(const std::string &name)
    {
      if(m_started)
        throw core::StatusCodeException(core::STATUS_CODE_NOT_ALLOWED);
        
      m_streamerName = name;
    }

    //-------------------------------------------------------------------------------------------------

    const std::string &EventSource::streamerName() const
    {
      return m_streamerName;
    }
    
    //-------------------------------------------------------------------------------------------------

    void EventSource::addCollector(const std::string &name)
    {
      if(m_started)
        throw core::StatusCodeException(core::STATUS_CODE_NOT_ALLOWED);
      
      auto findIter = m_collectorInfos.find(name);
      
      if(m_collectorInfos.end() != findIter)
        throw core::StatusCodeException(core::STATUS_CODE_ALREADY_PRESENT);
      
      CollectorInfo info;
      info.m_registered = false;
      m_collectorInfos.insert(CollectorInfoMap::value_type(name, info));
    }

    //-------------------------------------------------------------------------------------------------
    
    void EventSource::start()
    {
      if(m_started)
        throw core::StatusCodeException(core::STATUS_CODE_ALREADY_INITIALIZED);
      
      auto streamerPtr = PluginManager::instance()->create<core::EventStreamer>(m_streamerName);
      m_eventStreamer = std::shared_ptr<core::EventStreamer>(streamerPtr);
      
      if(!m_eventStreamer)
      {
        dqm_error( "EventSource::start(): Event streamer '{0}' not found in available streamers. Couldn't initialize!", m_streamerName );
        throw core::StatusCodeException(core::STATUS_CODE_NOT_FOUND);        
      }
      
      if(m_collectorInfos.empty())
      {
        dqm_error( "EventSource::start(): Event source '{0}' has no collector to send event. Couldn't initialize!", m_sourceName );
        throw core::StatusCodeException(core::STATUS_CODE_NOT_INITIALIZED);
      }
      
      m_bufferDevice = std::make_shared<xdrstream::BufferDevice>(2*1024*1024);
      
      Json::Value sourceInfo;
      this->getSourceInfo(sourceInfo);
      
      for(auto colIter : m_collectorInfos)
      {
        bool registered = this->registerMe(colIter.first, sourceInfo);
        colIter.second.m_registered = registered;
      }
      
      m_started = true;
    }
    
    //-------------------------------------------------------------------------------------------------
    
    void EventSource::sendEvent(const Event *const pEvent)
    {
      core::StringVector collectors;

      for(auto iter : m_collectorInfos)
        collectors.push_back(iter.first);
        
      this->sendEvent(collectors, pEvent);
    }
    
    //-------------------------------------------------------------------------------------------------
    
    void EventSource::sendEvent(const std::string &collector, const Event *const pEvent)
    {
      if(m_collectorInfos.end() == m_collectorInfos.find(collector))
      {
        dqm_error( "EventSource::sendEvent(col,evt): collector '{0}' not registered !", collector );
        throw core::StatusCodeException(core::STATUS_CODE_NOT_FOUND);
      }
      
      this->sendEvent(core::StringVector({collector}), pEvent);
    }
    
    //-------------------------------------------------------------------------------------------------
    
    void EventSource::sendEvent(const core::StringVector &collectors, const Event *const pEvent)
    {
      if(!m_started)
        throw core::StatusCodeException(core::STATUS_CODE_NOT_INITIALIZED);
        
      if(nullptr == pEvent)
        throw core::StatusCodeException(core::STATUS_CODE_INVALID_PTR);
      
      (void)m_bufferDevice->reset();
      auto status = m_eventStreamer->write(pEvent, m_bufferDevice.get());
      
      if(!XDR_TESTBIT(status, xdrstream::XDR_SUCCESS))
      {
        dqm_error( "EventSource::sendEvent(): event streamer failed: {0}", status );
        throw core::StatusCodeException(core::STATUS_CODE_FAILURE);
      }
      
      Json::Value sourceInfo;
      net::Buffer collectBuffer;
      auto model = collectBuffer.createModel();
      collectBuffer.setModel(model);
      model->handle(m_bufferDevice->getBuffer(), m_bufferDevice->getBufferSize());
      
      // send serialized event to all collectors 
      for(auto collector : collectors)
      {
        auto iter = m_collectorInfos.find(collector);
        
        if(m_collectorInfos.end() == iter)
        {
          dqm_error( "EventSource::sendEvent(): Collector '{0}' not found... Something is wrong !!!", collector );
          throw core::StatusCodeException(core::STATUS_CODE_NOT_FOUND);
        }
        
        // if not yet registered to the collector, do it
        if(!iter->second.m_registered)
        {
          // get it once
          if(sourceInfo.empty())
            this->getSourceInfo(sourceInfo);
            
          iter->second.m_registered = this->registerMe(iter->first, sourceInfo);
        }
        
        if(!iter->second.m_registered)
        {
          dqm_warning( "EventSource::sendEvent(): Source '{0}' not registered yet to collector '{1}'. Skipping ...", m_sourceName, collector );
          continue;
        }
        
        std::string collectCommand = "/dqm4hep/app/evtcol/" + collector + "/collect";
        m_client.sendCommand(collectCommand, collectBuffer);
      }  
    }

    //-------------------------------------------------------------------------------------------------

    void EventSource::getSourceInfo(Json::Value &info)
    {
      // source name
      info["source"] = m_sourceName;
      
      // host info
      StringMap hostInfo; Json::Value hostInfoValue;
      core::fillHostInfo(hostInfo);
      
      for(auto hi : hostInfo)
        hostInfoValue[hi.first] = hi.second;
      
      info["host"] = hostInfoValue;
      
      // collectors
      Json::Value collectorsValue;
      for(auto colIter : m_collectorInfos)
        collectorsValue.append(colIter.first);
      
      info["collectors"] = collectorsValue;
      
      // streamer name
      info["streamer"] = m_streamerName;
    }
    
    //-------------------------------------------------------------------------------------------------
    
    bool EventSource::registerMe(const std::string &collector, const Json::Value &info)
    {
      std::string requestName = "/dqm4hep/app/evtcol/" + collector + "/register";
      Json::StreamWriterBuilder builder;
      std::unique_ptr<Json::StreamWriter> writer(builder.newStreamWriter());
      std::ostringstream infoStr;
      writer->write(info, &infoStr);
      
      bool returnValue(false);
      net::Buffer requestBuffer;
      auto model = requestBuffer.createModel<std::string>();
      requestBuffer.setModel(model);
      model->move(std::move(infoStr.str()));
      
      m_client.sendRequest(requestName, requestBuffer, [&returnValue,&collector](const net::Buffer &buffer){
        Json::Value response;
        Json::CharReaderBuilder readerBuilder;
        std::unique_ptr<Json::CharReader> reader(readerBuilder.newCharReader());
        reader->parse(buffer.begin(), buffer.end(), &response, nullptr);
        
        const bool registered(response.get("registered", false).asBool());
        
        if(!registered)
        {
          const std::string message(response.get("message", "The event collector is maybe not available or is down !").asString());
          dqm_warning( "EventSource::registerMe(): Couldn't register to source to collector '{0}': {1}", collector, message );
          returnValue = false;
        }
        else
        {
          returnValue = true;
        }
      });
      
      return returnValue;
    }
    
    //-------------------------------------------------------------------------------------------------
    
    void EventSource::unregisterMe(const std::string &collector)
    {
      std::string commandName = "/dqm4hep/app/evtcol/" + collector + "/unregister";
      m_client.sendCommand(commandName, std::string(""));
    }

  }

}

